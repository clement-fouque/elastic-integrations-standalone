# https://www.elastic.co/docs/reference/fleet/elastic-agent-reference-yaml

outputs:
  default:
    type: elasticsearch
    hosts:
      - ${ELASTIC_HOST}
    # api_key: "example-key"
    username: ${ELASTIC_USERNAME}
    password: ${ELASTIC_PASSWORD}
    ssl.verification_mode: none

    # Performance preset for elasticsearch outputs. One of "balanced", "throughput",
    # "scale", "latency" and "custom".
    # Since the container is dedicated solely to running the agent, we don't need to reserve resources for other applications.
    preset: throughput

agent:
  download:
    sourceURI: "https://artifacts.elastic.co/downloads/"
  monitoring:
    enabled: false
    use_output: default
    namespace: default
    logs: false
    metrics: false
  features: {}

providers:
  local:
    vars:
      snyk_api_token: "${SNYK_API_TOKEN}"
      snyk_org_id: "${SNYK_ORG_ID}"
      elastic_integration_snyk_version: "${ELASTIC_INTEGRATION_SNYK_VERSION}"

inputs:
  - id: cel-snyk-c24bb091-1c4d-4cf5-b8e4-23992d32d205
    name: snyk-1
    revision: 1
    type: cel
    use_output: default
    meta:
      package:
        name: snyk
        version: ${local.elastic_integration_snyk_version}
    data_stream:
      namespace: default
    # package_policy_id: c24bb091-1c4d-4cf5-b8e4-23992d32d205
    streams:
      - id: cel-snyk.issues-c24bb091-1c4d-4cf5-b8e4-23992d32d205
        data_stream:
          dataset: snyk.issues
          type: logs
        config_version: 1
        interval: 24h
        resource.tracer:
          enabled: null
          filename: ../../logs/cel/http-request-trace-*.ndjson
          maxbackups: 5
        resource.url: https://api.snyk.io/
        state:
          end_point_type: /rest/orgs/
          version: "2024-04-29"
          issues_id: ${local.snyk_org_id}
          api_token: ${local.snyk_api_token}
          fetch_related_projects: true
          effective_severity_level:
            - critical
            - high
            - medium
            - low
            - info
          status:
            - open
            - resolved
          limit: 100
          want_more: false
        redact:
          fields:
            - issues_id
            - api_token
        max_executions: 1000
        program: |-
          state.with(
            get_request(
              state.url.trim_right("/") + state.?cursor.next.orValue(
                state.end_point_type + state.issues_id + "/issues?" + {
                  "version": [state.version],
                  // limit must be multiple of 10 for ... reasons; see spec. Always return a
                  // non-zero value, but otherwise do not ask for more than the user configured.
                  ?"limit": state.?limit.optMap(l, [string(max([1, int(l) / 10]) * 10)]),
                  ?"updated_after": has(state.?cursor.last_updated) ?
                    optional.of([state.cursor.last_updated])
                  : state.?lookback.optMap(l,
                    [string(now - duration(l))]
                  ),
                  ?"effective_severity_level": state.?effective_severity_level.optMap(l, [l.join(",")]),
                  ?"status": state.?status.optMap(s, [s.join(",")]),
                  ?"type": state.?type.optMap(t, [t]),
                  ?"scan_item.id": state.?scan_item_id.optMap(id, [id]),
                  ?"scan_item.type": state.?scan_item_type.optMap(t, [t]),
                  ?"ignored": state.?ignored.optMap(i, [string(i)]),
                }.format_query()
              )
            ).with(
              {
                "Header": {
                  "Accept": ["application/vnd.api+json"],
                  "Authorization": ["Token " + state.api_token],
                },
              }
            ).do_request().as(resp, (resp.StatusCode != 200) ?
              {
                "events": {
                  "error": {
                    "code": string(resp.StatusCode),
                    "id": string(resp.Status),
                    "message": "GET:" + (
                      (size(resp.Body) != 0) ?
                        string(resp.Body)
                      :
                        string(resp.Status) + " (" + string(resp.StatusCode) + ")"
                    ),
                  },
                },
                "want_more": false,
              }
            :
              bytes(resp.Body).decode_json().as(body, !has(body.data) ?
                {
                  "events": [],
                  "want_more": false,
                }
              :
                {
                  "events": body.data.map(issue,
                    (
                      state.fetch_related_projects == false || issue.?relationships.scan_item.links.related.orValue("") == "" ||
                      issue.?relationships.scan_item.data.type.orValue("") != "project"
                    ) ?
                      // not activated or no link or not a project, don't enrich
                      issue
                    :
                      // use the link to enrich
                      issue.with(
                        {
                          "relationships": issue.relationships.with(
                            {
                              "scan_item": issue.relationships.scan_item.with(
                                {
                                  "data": issue.relationships.scan_item.data.with(
                                    get_request(
                                      state.url.trim_right("/") + "/rest" + issue.relationships.scan_item.links.related + "?" + {"version": [state.version]}.format_query()
                                    ).with(
                                      {
                                        "Header": {
                                          "Accept": ["application/vnd.api+json"],
                                          "Authorization": ["Token " + state.api_token],
                                        },
                                      }
                                    ).do_request().as(resp, (resp.StatusCode != 200) ?
                                      {"_enrich_error_message": "Status code " + string(resp.StatusCode) + " received while fetching " + issue.relationships.scan_item.links.related}
                                    :
                                      bytes(resp.Body).decode_json().as(body,
                                        body.?data.orValue(
                                          {
                                            "_enrich_error_message": "No data received for " + issue.relationships.scan_item.links.related,
                                          }
                                        )
                                      )
                                    )
                                  ),
                                }
                              ),
                            }
                          ),
                        }
                      )
                  ).map(issue,
                    {
                      "message": issue.encode_json(),
                    }
                  ),
                  "cursor": {
                    ?"next": body.?links.next,
                    // Always keep last updated. This is our next periodic start point.
                    "last_updated": body.data.map(d, has(d.?attributes.updated_at),
                      timestamp(d.attributes.updated_at)
                    ).as(times, (size(times) == 0) ? state.?cursor.last_updated.orValue(now) : times.max()),
                  },
                  "want_more": has(body.?links.next),
                }
              )
            )
          )
        tags:
          - forwarded
          - snyk-issues
        publisher_pipeline.disable_host: true

# Send all logging output to stderr. The default is false.
agent.logging.to_stderr: true
